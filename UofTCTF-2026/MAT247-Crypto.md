# ðŸ”’ MAT247 - CTF Challenge Writeup

**Challenge**: MAT247  
**Category**: Crypto  
**Status**: âœ… Solved   
**Flag**: `uoftctf{jus7_4_s1mple_tr4nslation_t0_GF(p^12)}` 


# MAT247
**Posted Jan 10, 2026**

## Overview
The challenge provides a Python script `chall.py` and an output file `output.txt`.
The script defines a large prime $p$ and a $12 \times 12$ matrix $A$ over $GF(p)$.
It generates the flag bits one by one using two different methods:

```python
if bit == '0':
    print(gen_commuting_matrix(A))
else:
    print(np.linalg.matrix_power(A, random.randrange(p**12-1)))
```

Our task is to determine, for each of the 368 output matrices, whether it was generated as a general commuting matrix (Bit 0) or a power of $A$ (Bit 1).

## Idea
The problem statement hints at the structure of matrices commuting with $A$: "S = p(T) for some polynomial T".
We analyzed the matrix $A$ and found its characteristic polynomial is **irreducible** over $GF(p)$.
This means the subalgebra generated by $A$ is isomorphic to the finite field $GF(p^{12})$.
All matrices commuting with $A$ are elements of this field.

- **Bit 1**: $S = A^k$. This is an element of the cyclic subgroup generated by $A$.
- **Bit 0**: $S$ is a random element of $GF(p^{12})^*$.

The multiplicative group $GF(p^{12})^*$ has order $N = p^{12}-1$.
We can use the **subgroup membership problem** to distinguish the two cases.
We found small prime factors $q$ of $N$ such that $A^{(N/q)} = I$ (the identity matrix).
This implies $A$ lies in a subgroup of index $q$. Any power $A^k$ must also satisfy $(A^k)^{(N/q)} = I$.

However, a random element of $GF(p^{12})^*$ satisfies this condition with probability only $1/q$.
If a challenge matrix $S$ satisfies $S^{(N/q)} \neq I$, it **cannot** be a power of $A$ (implied Bit 0).
If it satisfies the condition for several large $q$, it is almost certainly a power of $A$ (Bit 1).

## Solve
We implemented a solver to find suitable factors $q$.
We identified $q \in \{2, 3, 17, 26119\}$ as valid distinguishers (where $A^{(N/q)} = I$).
The factor 26119 provided a very strong discriminator ($p \approx 4 \times 10^{-5}$ for false positives).

We processed the 368 matrices in parallel chunks.
Initially, using only small factors (2, 3, 17), we encountered a meaningful ambiguity where the character `t` was misidentified as `|` due to a probabilistic false positive (a random matrix happened to pass the checks).
By adding the factor $q=26119$, we correctly resolved the bits:

- **False Positive**: `|` (Bit pattern `01111100`)
- **Corrected**: `t` (Bit pattern `01110100`)

The bit difference confirmed that one matrix was Random (Bit 0) but previously guessed as Power (Bit 1).

Putting it all together, we decoded the binary string.

## Here is the complete solution script:

```python
import sys
import re

# Parameters
p = 202184226278391025014930169562408816719

def mat_mul(A, B, p):
    C = [[0]*12 for _ in range(12)]
    B_t = list(zip(*B))
    for i in range(12):
        row = A[i]
        for j in range(12):
            col = B_t[j]
            s = 0
            for k in range(12):
                s += row[k] * col[k]
            C[i][j] = s % p
    return C

def identity(n):
    I = [[0]*n for _ in range(n)]
    for i in range(n): I[i][i] = 1
    return I

def mat_pow(A, exp, p):
    res = identity(12)
    base = A
    while exp > 0:
        if exp % 2 == 1:
            res = mat_mul(res, base, p)
        base = mat_mul(base, base, p)
        exp //= 2
    return res

def parse_output(filename):
    with open(filename, 'r') as f:
        try:
            content = f.read()
        except:
             # Fallback encoding
             with open(filename, 'r', encoding='utf-16') as f2:
                 content = f2.read()

    nums = [int(x) for x in re.findall(r'\d+', content)]
    matrices = []
    for i in range(0, len(nums), 144):
        chunk = nums[i:i+144]
        if len(chunk) < 144: break
        mat = []
        for r in range(12):
            mat.append(chunk[r*12 : (r+1)*12])
        matrices.append(mat)
    return matrices

# Distinguishers: Small prime factors of p^12 - 1
# Identified via factorization and verification that A^(N/q) == I
distinguishers = [2, 3, 17, 26119]

N = pow(p, 12) - 1
I = identity(12)

matrices = parse_output("output.txt")
bits = ""

print(f"Processing {len(matrices)} matrices...")
for idx, M in enumerate(matrices):
    is_power = True
    for q in distinguishers:
        exp = N // q
        M_check = mat_pow(M, exp, p)
        
        # Check if result is Identity
        is_pos_identity = True
        for i in range(12):
            for j in range(12):
                if M_check[i][j] != I[i][j]:
                    is_pos_identity = False; break
            if not is_pos_identity: break
        
        if not is_pos_identity:
            is_power = False
            break
    
    bit = '1' if is_power else '0'
    bits += bit

print(f"Recovered {len(bits)} bits.")

# Decode bits to flag
flag = ""
try:
    for i in range(0, len(bits), 8):
        byte = bits[i:i+8]
        val = int(byte, 2)
        flag += chr(val)
    print(f"Flag: {flag}")
except Exception as e:
    print(f"Decoding error: {e}")
```

```bash
$ python3 solve.py
...
Flag: uoftctf{jus7_4_s1mple_tr4nslation_t0_GF(p^12)}
```
