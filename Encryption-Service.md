# ðŸ”’ Encryption Service - CTF Challenge Writeup  

**Challenge**: Encryption Service   
**Category**: Crypto / Misc   
**Status**: âœ… Solved   
**Flag**: `uoftctf{b4by_w1r3sh4rk_an4lys1s}`  ðŸ”“


## Overview 
The challenge provides a Python script `enc.py`, a shell script `run.sh`, and a Dockerfile.
The service takes user input, appends the flag to it, and then pipes the whole content to an encryption script using `xargs`:

```bash
cat /flag.txt >> "$OUTFILE"
echo "$(cat "$OUTFILE" | xargs /app/enc.py)"
```

`enc.py` is designed to take the first argument as the **hex key** and the subsequent arguments as plaintext to encrypt using AES-CBC.
However, `run.sh` initializes the file with a random 16-byte key (32 hex chars) at the start.

Our task is to recover the flag which is encrypted along with our input.

## Idea
The vulnerability lies in how `xargs` handles large inputs.
`xargs` has a limit on the maximum command line length (ARG_MAX). If the input exceeds this limit, `xargs` splits the arguments and executes the command (`enc.py`) multiple times.

1.  **First Execution**: `enc.py <random_key> <input_chunk_1>...`
    - This corresponds to the initial lines of the file which contain the random key generated by the server.
    
2.  **Second Execution**: `enc.py <next_argument> <input_chunk_2>...`
    - If we provide enough input, we can force `xargs` to invoke `enc.py` a second time.
    - Crucially, the *first argument* to this second invocation will be an element from our input stream.
    - Since we control the input, we can ensure that this "first argument" is a valid hex key that *we know* (e.g., 32 zeros).
    - The flag, which is appended to the end of the input, will be included in the arguments for this second (or subsequent) execution.

Therefore, the flag will be encrypted using our chosen key instead of the server's random key.

## Solve
We implemented a solver script `solve.py` to automate the attack:
1.  Connect to the service `nc 34.86.4.154 5000`.
2.  Send a massive amount of data (10,000 lines of 32-character "0" strings) to fill the command line buffer.
3.  Terminate input with `EOF`.
4.  Receive the response, which contains multiple hex strings (outputs from each `enc.py` run).
5.  Iterate through each output line and attempt to decrypt it using our known key (`00` * 16).
6.  Search for the flag format `uoftctf{` in the decrypted text.

Running the script successfully recovered the flag:
`uoftctf{x4rgs_d03sn7_run_in_0n3_pr0c3ss}`

## Solver
Here is the complete solution script:

```python
import socket
import time
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

# Configuration
HOST = '34.86.4.154'
PORT = 5000
KNOWN_KEY_HEX = "00" * 16  # 32 hex chars (16 bytes)
KNOWN_KEY = bytes.fromhex(KNOWN_KEY_HEX)
NUM_LINES = 10000  # Enough to trigger xargs split

def decrypt(iv_hex, ct_hex):
    try:
        iv = bytes.fromhex(iv_hex)
        ct = bytes.fromhex(ct_hex)
        cipher = AES.new(KNOWN_KEY, AES.MODE_CBC, iv)
        pt = unpad(cipher.decrypt(ct), AES.block_size)
        return pt
    except Exception as e:
        return None

def solve():
    print(f"[*] Connecting to {HOST}:{PORT}...")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))

    # Read welcome message
    data = s.recv(1024).decode()
    print(data)

    print(f"[*] Sending {NUM_LINES} lines of known key payload...")
    payload = (KNOWN_KEY_HEX + "\n") * NUM_LINES
    s.sendall(payload.encode())
    s.sendall(b"EOF\n")

    print("[*] Receiving response...")
    response = b""
    while True:
        try:
            chunk = s.recv(4096)
            if not chunk:
                break
            response += chunk
        except socket.timeout:
            break
            
    s.close()
    
    lines = response.decode().splitlines()
    print(f"[*] Received {len(lines)} lines of output.")

    for line in lines:
        line = line.strip()
        if len(line) < 32:
            continue
        
        # Assumption: line is hex string.
        try:
            int(line, 16)
        except ValueError:
            continue

        iv_hex = line[:32]
        ct_hex = line[32:]
        
        if not ct_hex:
            continue

        pt = decrypt(iv_hex, ct_hex)
        if pt:
            try:
                pt_str = pt.decode('utf-8', errors='ignore')
                if "uoftctf" in pt_str:
                    print("\n[+] FOUND FLAG!")
                    print(pt_str)
                    return
            except:
                pass
    
    print("[-] Flag not found in response.")

if __name__ == "__main__":
    solve()
```
